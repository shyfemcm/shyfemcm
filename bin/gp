#!/bin/bash
#
#------------------------------------------------------------------------
#
#    Copyright (C) 1985-2020  Georg Umgiesser
#
#    This file is part of SHYFEM.
#
#------------------------------------------------------------------------
#
# shell for gnuplot
#
#########################################################

version=2.06

# 2.06	01.02.2025	bug fix for parsing time in date string
# 2.05	17.10.2024	lt for dash substituted with dt
# 2.04	06.05.2024	debug option and ParseTime()
# 2.03	07.03.2024	adjust paths for helper routines
# 2.02	03.03.2024	use absolute paths in calling other scripts
# 2.01	27.01.2024	new option -solid
# 2.00	09.09.2023	can accept 24 hours date (GetSecs)
# 1.99	29.11.2022	use -u if given for 2 data column
# 1.98	19.02.2022	bug fix for option -labels
# 1.97	15.01.2022	new option -labels
# 1.96	27.06.2021	use GetSecs and not busybox to get seconds
# 1.95	04.12.2020	more documentation in help
# 1.94	05.03.2018	do not used date if time col is 0
# 1.93	01.03.2018	ignore lines starting with #
# 1.92	16.02.2018	offset introduced (also relative)
# 1.91	04.02.2018	delete _ in x/y axis and title (DeleteUnderscore)
# 1.90	20.10.2017	handle time string automatically, auto range
# 1.81	18.04.2017	new -xrotate to rotate x labels
# 1.80	18.04.2017	new -date and -xformat to deal with date as time column
# 1.72	07.09.2016	new -style fill
# 1.71	05.06.2015	new -dash for different dash styles
# 1.70	27.05.2015	new -ty2 -ry2 -y2 for second y-axis
# 1.61	27.04.2015	-sy now working, logarithmic axis introduced
# 1.60	23.01.2014	new options -color -width -showcolor, restructuring
# 1.51	23.01.2012	new option -logo
# 1.50	05.05.2011	new option -sy (not yet working)
# 1.46	23.10.2009	new option -verbose
# 1.45	24.08.2009	new option -bw (is already default)
# 1.44	20.08.2009	better handling of -png option
# 1.43	04.02.2002	accepts -o option
# 1.42	30.01.2002	accepts -xtics option
# 1.41	30.11.2001	accepts -style option special -> small red box
# 1.40	29.11.2001	accepts -style option
# 1.31			accepts -grid
# 1.30			accepts -ppp and -sx
# 1.23			accepts -u all
# 1.22			remove parts of legend (option -l)
# 1.21			better conti line treatment, signal error in option
# 1.20			specify x/y range
# 1.10			using different columns
# 1.00			original version

######################################################### defaults

script=$(realpath $0)
FEMBIN=$(dirname $script)

gpversion=$( gnuplot --version | sed -e 's/ *patchlevel.*//' \
			| sed -e 's/gnuplot *//' )
gpmajor=$( echo $gpversion | sed -e 's/\..*//' )
#echo $gpversion $gpmajor

debug="YES"
debug="NO"
[ $debug = "YES" ] && echo "debug = $debug" >&2

title="Timeseries"
type="monochrome"
orientation="landscape"
terminal="postscript"
usinggiven="NO"
using="using 1:2"
grid="NO"
xlog="NO"
ylog="NO"
date="NO"
idate="NO"
offset=""
date_format="%Y-%m-%d::%H:%M:%S"	#internal date format for gnuplot
xformat=""				#how date is written in plot
xrotate=0				#rotate x labels
verbose="NO"
nolegend="xyz*^+="	# something very unlikely
labels=""		# no labels file by default
ppp="0"			# plots per page
xfact="1"		# scaling of x axis
yfact="1"		# scaling of y axis
style=""
color=""
solid=""
width=""
xtics=""
outfile=""
ghost='gv'

logo="0"
logo_file=$FEMBIN/logo/logo.eps			#file to be included as logo
logo_where="0.92 0.92 0 0.99"			#position of included file

######################################################### programs

gnuplot="/usr/bin/gnuplot"
psgnu="$FEMBIN/gps/psgnu.pl"
extractcol="$FEMBIN/col/extractcol.pl"
scalecol="$FEMBIN/col/scalecol.pl"
xrange_pl="$FEMBIN/xrange.pl"
gpsmerge="$FEMBIN/gps/gpsmerge.pl"
gpsinsert="$FEMBIN/gps/gpsinsert.sh"
gpgnustyle="$FEMBIN/gpgnustyle.pl"

######################################################### copyright

copy1="File automatically generated by gp"
copy2="gp - shell for gnuplot                 Version $version"
copy3="Copyright (c) 1998-2017 Georg Umgiesser - ISMAR-CNR"
copy4="e-mail: georg.umgiesser@ismar.cnr.it"

######################################################### help - usage

Copy()
{
  echo "$copy2"
  echo "$copy3"
}

Usage()
{
  echo "Usage: gp [ -h | -help ] [ options ] file[s]"
}

FullUsage()
{
  echo ""

  Copy
  echo ""
  Usage

  echo ""
  echo "Available options:"
  echo "  -h|-help         this help"
  echo "  -showcolor       shows available color names"
  echo "  -c|-bw           color|black&white output (-bw is default)"
  echo "  -o outfile       plot to outfile (show with ghostview if -)"
  echo "  -png             output in PNG format"
  echo "  -p               portrait mode"
  echo "  -ppp n           put n plots per page (default: all plots)"
  echo "  -grid            plots grid underneath plot"
  echo "  -xlog|-ylog      use logarithmic scaling for x/y axis"
  echo "  -style style     sets line style for following files"
  echo "  -color color     sets line color for following files"
  echo "  -solid solid     transparency for line filling [0-1]"
  echo "  -width width     sets line width (integer) for following files"
  echo "  -dash dash       sets dash style (integer) for following files"
  echo "  -xtics xtics     sets tics style for x-axis"
  echo "  -date            time column is in format YYYY-mm-dd::HH:MM:SS"
  echo "  -xformat xformat use this format for x axis if given in date format"
  echo "  -xrotate deg     rotate x labels by deg degrees"
  echo "  -u  x:y          using columns x and y for x/y values (Default 1:2)"
  echo "  -u  all          plot all columns (x:all also possible)"
  echo "  -t  title        give title of plot"
  echo "  -tx xlabel       give x-label of plot"
  echo "  -ty ylabel       give y-label of plot"
  echo "  -rx xmin:xmax    give x-range of plot"
  echo "  -ry ymin:ymax    give y-range of plot"
  echo "  -offset offset   give offsets for all sides (4 values)"
  echo "  -ty2 ylabel      give y-label of plot for second y-axis"
  echo "  -ry2 ymin:ymax   give y-range of plot for second y-axis"
  echo "  -y1              use first y-axis for following files (default)"
  echo "  -y2              use second y-axis for following files"
  echo "  -sx xfact        scale x-coordinate with xfact"
  echo "  -sy yfact        scale y-coordinate with yfact"
  echo "  -label label     inserts text given in label"
  echo "  -labels lfile    inserts labels from file lfile"
  #echo "  -lrotate         rotates labels"
  echo "  -l  string       string that is removed from legend if found"
  echo "  -logo            insert logo"
  #echo "  -logo_where pos  insert logo at position pos (see gpsinsert)"
  echo "  -verbose         writes some diagnostic messages"
  echo ""
  echo "Possible style options are:"
  echo "   lines, points, linespoints, impulses, dots"
  echo "   steps, fsteps, histeps"
  echo "   errorbars, xerrorbars, yerrorbars (two data columns)"
  echo "   fill (two data columns)"
  echo "Possible color options are:"
  echo "   red, blue, green, etc.."
  echo "   to see all color names run gp with -showcolor"
  echo "Possible dash styles are: 1,2,3,... (1 solid line)"
  echo "Possible xtics options are:"
  echo "   xdtics, xmtics, mesi, months or (custom)"
  echo "Column 0 indicates automatically generated index"
  echo "-u 0:all uses generated index on all data columns"
  echo "xformat is determined automatically but can be given explicitly"
  echo "  examples: %Y-%m-%d::%H:%M:%S   %d-%H   %H:%M:%S"
  echo "  -xformat option implies -date"
  echo "offset is l,r,t,b in units of x and y axis (default 0,0,0,0)"
  echo "  use r for fraction of axis (e.g., 0,0,0.5r,0 for 50% on top of plot"
  echo "in case of date/time format specify xrange as "
  echo "  \"2020-12-01:\""
  echo "  \"2020-12-01:2020-12-03\""
  echo "  \"2020-12-01::00:00:00:2020-12-04::12:00:00"\"
  echo "labels lfile may contain following commands:"
  echo "  set label 'text' at x,y [left|center|right]"
  echo "  set arrow from x,y to x,y [nohead|head|backhead|heads]"
  echo ""
}

ErrorOption()
{
  echo "No such option : $1"
}

ErrorOptionPosition()
{
  echo "No such option or in wrong place: $1"
}

MakeLegend()	#substitutes _ with blank and removes string in $nolegend
{
  echo $1 | sed -e "s/$nolegend//g" | sed -e 's/_/ /g' | sed -e 's/ *$//'
}

DeleteUnderscore()
{
  echo $1 | sed -e 's/_/ /g' | sed -e 's/ *$//'
  #echo $1
}

ShowColor()
{
  $gnuplot <<EOI
show palette colornames
quit
EOI
}

#-------------------------------------------------------------------

GiveNames()
{
  # checks first line of files and uses it as filename if starting with letter
  # else just appends old file names to list of files to be processed

  newfiles=""

  for file in $files
  do
    line=`head -1 $file | perl -p -e 's/\s*\S+\s+//'`
    newfile=`echo $line | grep '^[a-zA-Z]'`
    if [ -n "$newfile" ]; then
      #echo "filename is $newfile"
      newfiles="$newfiles $newfile"
      mv -f $file $newfile
    else
      newfiles="$newfiles $file"
    fi
  done

  files=$newfiles
}

HandleFiles()
{
  # inserts file into list with actual styles

  n=${#afiles[@]}	#number of array elements (indexing starts from 0)

  for file
  do
    afiles[$n]=$file
    astyles[$n]=$style
    acolors[$n]=$color
    asolids[$n]=$solid
    awidths[$n]=$width
    aaxes[$n]=$axes
    adash[$n]=$dash
    ((n++))
  done
}

InsertFiles()
{
  local s=${astyles[0]}
  local c=${acolors[0]}
  local t=${asolids[0]}
  local w=${awidths[0]}
  local x=${aaxes[0]}
  local d=${adash[0]}

  local n=0

  for file in $files
  do
    #echo "inserting $file"
    afiles[$n]=$file
    astyles[$n]=$s
    acolors[$n]=$c
    asolids[$n]=$t
    awidths[$n]=$w
    aaxes[$n]=$x
    adash[$n]=$d
    ((n++))
  done
}

ShowFiles()
{
  n=${#afiles[@]}
  m=0
  mm=1

  echo "-------- info on files and styles --------------"
  while [ $m -lt $n ]
  do
     f=${afiles[$m]}
     s=${astyles[$m]}
     c=${acolors[$m]}
     t=${asolids[$m]}
     w=${awidths[$m]}
     x=${aaxes[$m]}
     d=${adash[$m]}
     echo "$mm/$n $f $s $c $t $w $x $d"
     ((m++))
     ((mm++))
  done
  echo "------------------------------------------------"
}

#-------------------------------------------------------------------

GetFirstAndLastDataLine()
{
  file=${afiles[0]}	#we only look at first file
  first_data_line=$( cat $file | grep -v '^\s*$' | grep  -v '^\s*#' | head -1 )
  last_data_line=$( tac $file | grep -v '^\s*$' | grep  -v '^\s*#' | head -1 )
  if [ $debug = "YES" ]; then
    echo "first/last data line:"	>&2
    echo "  $first_data_line"		>&2
    echo "  $last_data_line"		>&2
  fi
  #first_data_line=$( grep --max-count 1 -E -v '^\s*#' $file )
  #last_data_line=$( tac $file | grep --max-count 1 -E -v '^\s*#' )
}

CheckForDate()
{
  [ $date = "YES" ] && return

  #file=${afiles[0]}	#we only look at first file
  #first_line=`head -1 $file`

  first_line=$first_data_line
  first_time=`echo $first_line | sed -E 's/^\s+//' | sed -E 's/\s+.*//'`

  if [[ $first_time == *::* ]]; then
    date="YES"
  fi

  tcol=$( echo $using | sed -E 's/^using\s*//' | sed -E 's/:.*//' )
  #echo "time column: $tcol"

  if [ "$tcol" = "0" ]; then
    date="NO"
  fi
}

HandleXaxis()
{
  # this tries to see in what format the x-axis has to be written
  # it sets variable $xformat

  local sec1 sec2 secs hours days months years

  [ -n "$xformat" ] && return	#return if already given

  #file=${afiles[0]}	#we only look at first file
  #first_line=`head -1 $file`

  first_line=$first_data_line
  last_line=$last_data_line

  first_time=`echo $first_line | sed -E 's/^\s+//' | sed -E 's/\s+.*//'`
  last_time=`echo $last_line | sed -E 's/^\s+//' | sed -E 's/\s+.*//'`

  [ -n "$xlow" ] && first_time=$xlow
  [ -n "$xhigh" ] && last_time=$xhigh

  if [ $debug = "YES" ]; then
    echo "HandleXaxis:"							>&2
    echo "  first_data_line=$first_data_line"				>&2
    echo "  last_data_line=$last_data_line"				>&2
    echo "  first_time=$last_time"					>&2
    echo "  last_time=$last_time"					>&2
    echo "  xrange=$xrange"						>&2
  fi

  ParseTime $first_time
  #GetSecs $first_time

  sec1=$( GetSecs $first_time )
  sec2=$( GetSecs $last_time )
  #sec1=$( busybox date -D "%Y-%m-%d::%H:%M:%S" -d $first_time +%s )
  #sec2=$( busybox date -D "%Y-%m-%d::%H:%M:%S" -d $last_time +%s )
  secs=$(( $sec2 - $sec1 ))
  [ $debug = "YES" ] && echo "time window: $secs seconds" >&2

  xformat="%Y-%m-%d::%H:%M:%S"	#complete format - not used

  if [ $secs -lt 60 ]; then
    xformat=%S
    return
  elif [ $secs -lt 3600 ]; then
    xformat=%M:%S
    return
  fi
  hours=$(( $secs / 3600 ))
  if [ $hours -lt 24 ]; then
    xformat=%H:%M
    return
  fi
  days=$(( $hours / 24 ))
  if [ $days -lt 10 ]; then
    xformat=%d::%H
    #xformat="%H:%M\n%y-%m-%d"
    xformat="%H:%M\n%Y-%m-%d"
    return
  elif [ $days -lt 30 ]; then
    xformat=%m-%d
    return
  fi
  months=$(( $days / 30 ))
  if [ $months -lt 6 ]; then
    xformat=%m-%d
    return
  elif [ $months -lt 12 ]; then
    xformat=%m
    return
  fi
  years=$(( $months / 12 ))
  if [ $years -lt 4 ]; then
    xformat=%Y-%m
    return
  else
    xformat=%Y
    return
  fi

  [ $debug = "YES" ] && echo "automatically determined xformat: $xformat" >&2
}

GetSecs()
{
  local string=$1

  ParseTime $string

  date=$fulldate

  if [ "$debug" = "YES" ]; then
    echo "GetSecs:"					>&2
    echo "  $string $date $hour $day $d"		>&2
  fi

  date --date="$isodate" +%s
}

ParseTime()
{
  local string=$1

  local year month day hour minute second
  local date time

  if [[ $string =~ "::" ]]; then	# have both date and time
    date=$( echo $string | sed -E 's/::.*$//' )
    time=$( echo $string | sed -E 's/^.*:://' )
  elif [[ $string =~ "-" ]]; then	# has only date
    date=$string
  elif [[ $string =~ ":" ]]; then	# has only time
    time=$string
    echo "no date in string: $string ... cannot parse"	>&2
    exit 1
  else
    echo "cannot parse: $string"		>&2
    exit 1
  fi

  if [ $debug == "YES" ]; then
    echo "ParseTime:"				>&2
    echo "  string = $string"			>&2
    echo "  date = $date"			>&2
    echo "  time = $time"			>&2
  fi

  if [ -n "$date" ]; then
    year=$( echo $date | cut -d- -f1 )
    month=$( echo $date | cut -d- -f2 )
    day=$( echo $date | cut -d- -f3 )
  fi
    
  if [ -n "$time" ]; then
    hour=$( echo $time | cut -d: -f1 )
    minute=$( echo $time | cut -d: -f2 )
    second=$( echo $time | cut -d: -f3 )
  fi

  [ -z "$hour" ] && hour="00"
  [ -z "$minute" ] && minute="00"
  [ -z "$second" ] && second="00"
  
  onlydate=$year-$month-$day

  if [ "$hour" -eq 24 ]; then		# roll to next day
    onlydate=$( date --date="$onlydate +1 day" +%Y-%m-%d )
    hour=00
  fi

  onlytime=$hour:$minute:$second
  fulldate=$onlydate::$onlytime
  isodate=${onlydate}T${onlytime}

  if [ $debug == "YES" ]; then
    echo "ParseTime 2:"				>&2
    echo "  fulldate = $fulldate"		>&2
  fi
}

#-------------------------------------------------------------------

Plotting()
{
  echo 'plot \' >> gnu.tmp

   eol=' \'	#end of line
  cont='  '	#continuation of line

  while [ $# -gt 0 ]
  do

    file=${afiles[$1]}
    style=${astyles[$1]}
    color=${acolors[$1]}
    solid=${asolids[$1]}
    width=${awidths[$1]}
    axes=${aaxes[$1]}
    dash=${adash[$1]}

    with=""
    lc=""
    lw=""
    dt=""
    fs=""
    use=$using
    if [ -n "$style" ]; then
      with="w $style"
      if [ $style = "special" ]; then
        with="w points pt 4"
        special="1"
      elif [ $style = "special2" ]; then
        with="w xerrorbars"
        [ $usinggiven = "NO" ] && use="using 1:2:3"
        special="2"
      elif [ $style = "xerrorbars" ]; then
        [ $usinggiven = "NO" ] && use="using 1:2:3"
      elif [ $style = "yerrorbars" ]; then
        [ $usinggiven = "NO" ] && use="using 1:2:3"
      elif [ $style = "errorbars" ]; then
        [ $usinggiven = "NO" ] && use="using 1:2:3"
      elif [ $style = "fill" ]; then	#needs two data columns
        [ $usinggiven = "NO" ] && use="using 1:2:3"
        with="w filledcurves"
      fi
    fi
    if [ -n "$axes" ]; then
      axes="axes $axes"
    fi
    if [ -n "$dash" ]; then
      dt="dt $dash"
    fi
    if [ -n "$color" -a "$color" != "none" ]; then
      lc="lc rgb '$color'"
    fi
    if [ -n "$width" ]; then
      lw="lw $width"
    fi
    if [ -n "$solid" -a "$solid" != "none" ]; then
      fs="fs transparent solid $solid"
    fi

    [ -z "$2" ] && eol=' '

    legend=`MakeLegend $file`
    line="     \"$file\" $use $axes title \"$legend\" $with $dt $fs $lc $lw"
    echo "$cont $line $eol" >> gnu.tmp
    cont=', '

    shift

  done

  echo "" >> gnu.tmp
  echo "quit" >>  gnu.tmp
}

PlotFiles()
{
  cp gnu.tmp gnuhead.tmp
  rm -f out.[1-9]*.ps

  nfiles=${#afiles[@]}

  [ $ppp -eq 0 ] && ppp=$nfiles		#all plots on one page

  page=0
  index=0

  while [ $index -lt $nfiles ]
  do
    ((page++))
    fnames=""
    indices=""
    special="NO"

    for f in `seq $ppp`
    do
      file=${afiles[$index]}
      fnames="$fnames $file"
      indices="$indices $index"
      ((index++))
      shift
    done

    if [ $verbose = "YES" ]; then
      echo "page: $page  files: $fnames  indices: $indices"
    fi
    cp gnuhead.tmp gnu.tmp

    Plotting $indices
    $gnuplot gnu.tmp
    [ $orientation = "landscape" ] && $psgnu out.ps
    [ $special != "NO" ] && AdjustSpecial $special

    [ -f out.ps ] && mv out.ps out.$page.ps
  done
  [ -f out.1.ps ] && $gpsmerge out.[1-9]*.ps > out.ps
}

#-------------------------------------------------------------------

mesi='\
         ""  0 , "Gen"  0.5 , ""  1 , "Feb"  1.5 , \
         ""  2 , "Mar"  2.5 , ""  3 , "Apr"  3.5 , \
         ""  4 , "Mag"  4.5 , ""  5 , "Giu"  5.5 , \
         ""  6 , "Lug"  6.5 , ""  7 , "Ago"  7.5 , \
         ""  8 , "Set"  8.5 , ""  9 , "Ott"  9.5 , \
         "" 10 , "Nov" 10.5 , "" 11 , "Dic" 11.5 , \
         "" 12'

months='\
         ""  0 , "Jan"  0.5 , ""  1 , "Feb"  1.5 , \
         ""  2 , "Mar"  2.5 , ""  3 , "Apr"  3.5 , \
         ""  4 , "May"  4.5 , ""  5 , "Jun"  5.5 , \
         ""  6 , "Jul"  6.5 , ""  7 , "Aug"  7.5 , \
         ""  8 , "Sep"  8.5 , ""  9 , "Oct"  9.5 , \
         "" 10 , "Nov" 10.5 , "" 11 , "Dec" 11.5 , \
         "" 12'

#-------------------------------------------------------------------

AdjustSpecial()
{
  #for some reason special must always be last option -> color problems
  laststyle=`grep '^LT' out.ps | tail -1`
  echo "adjusting special style: $laststyle"
  $gpgnustyle $1 out.ps > out.tmp
  mv out.tmp out.ps
}

DetermineXrange()
{
#  first_date=$( echo $first_data_line | sed -E 's/^\s*//' \
#		| sed -E 's/\s+.*//' | sed -E 's/::/ /' )
#  last_date=$( echo $last_data_line | sed -E 's/^\s*//' \
#		| sed -E 's/\s+.*//' | sed -E 's/::/ /' )
  first_date=$( echo $first_data_line | sed -E 's/^\s*//' \
		| sed -E 's/\s+.*//' )
  last_date=$( echo $last_data_line | sed -E 's/^\s*//' \
		| sed -E 's/\s+.*//' )

  echo "first and last date: $first_date - $last_date"

  #fs=$( date --date "$first_date" +%s )
  #ls=$( date --date "$last_date" +%s )
  #echo "period: $fs $ls"

  xrange=$( $xrange_pl -round "$first_date:$last_date" )
  echo "after rounding xrange: $xrange"

  #secs=$(( ls - fs ))
  #hours=$(( $secs / 3600 ))
  #days=$(( $hours / 24 ))
  #months=$(( $days / 30 ))
  #years=$(( $months / 12 ))
  #echo "period: $secs $hours $days $months $years"
}

HandleXrange()
{
  SplitXrange

  xrange=""
  [ -z "$xlow" -a -z "$xhigh" ] && return

  [ -n "$xlow" ] && xrange="$xrange\"$xlow\""
  xrange="$xrange:"
  [ -n "$xhigh" ] && xrange="$xrange\"$xhigh\""

  #echo "HandleXrange: $xrange"
}

SplitXrange()
{
  xlow=""
  xhigh=""

  if [[ -n $xrange ]]; then
    out=$( $xrange_pl $xrange)
    xlow=$( echo $out | sed -E 's/(.*)=.*/\1/' )
    xhigh=$( echo $out | sed -E 's/.*=(.*)/\1/' )
    #echo "debug SplitXrange: $out $xlow $xhigh"
  fi

  #echo "SplitXrange: ($out)  xlow=$xlow  xhigh=$xhigh"
}

SplitLabel()
{
  local label=$1

  #echo "splitting label: $label"

  label_x=$( echo $label | cut -f 1 -d ',' )
  label_y=$( echo $label | cut -f 2 -d ',' )
  label_text="$( echo $label | cut -f 3 -d ',' )"

  label_text=$( echo $label_text | sed -e 's/"//g' )

  #echo "SplitLabel: $label_x - $label_y - $label_text"
}

InsertLabels()
{
  local labels=$1

  echo "" >> gnu.tmp

  n=1
  while read label; do
    [ $verbose = "YES" ] && echo "Label No. $n : $label"
    echo $label >> gnu.tmp
    n=$((n+1))
  done < $labels
}

#-------------------------------------------------------------------
# start routine
#-------------------------------------------------------------------

declare -a afiles		#must be global
declare -a astyles
declare -a acolors
declare -a asolids
declare -a awidths
declare -a aaxes
declare -a adash

######################################################### read options

while [ -n "$1" ]
do
   case $1 in
	-c)		type="color";;
	-bw)		type="monochrome";;
	-o)		outfile=$2; shift;;
	-p)		orientation="portrait";;
	-ppp)		ppp=$2; shift;;
	-grid)		grid="YES";;
	-xtics)		xtics=$2; shift;;
	-style)		style=$2; shift;;
	-color)		color=$2; shift;;
	-solid)		solid=$2; shift;;
	-width)		width=$2; shift;;
	-dash)		dash=$2; shift;;
	-xlog)		xlog="YES";;
	-ylog)		ylog="YES";;
	-png)		terminal="png";;
	-date)		date="YES";;
	-idate)		idate="YES";;
	-xformat)	xformat=$2; date="YES"; shift;;
	-xrotate)	xrotate=$2; shift;;
	-u)		using="using $2"; usinggiven="YES"; shift;;
	-t)		title=$2; shift;;
	-tx)		xlabel=$2; shift;;
	-ty)		ylabel=$2; shift;;
	-rx)		xrange="$2"; shift;;
	-ry)		yrange=$2; shift;;
	-offset)	offset=$2; shift;;
	-ty2)		y2label=$2; shift;;
	-ry2)		y2range=$2; shift;;
	-y1)		axes="x1y1";;
	-y2)		axes="x1y2";;
	-sx)		xfact=$2; shift;;
	-sy)		yfact=$2; shift;;
	-l)		nolegend=$2; shift;;
	-label)		label=$2; shift;;
	-labels)	labels=$2; shift;;
	-logo)		logo=1;;
	-logo_where)	logo=1; logo_where=$2; shift;;
	-labels)	labels=$2; shift;;
	-verbose)	verbose="YES";;
	-showcolor)	ShowColor; exit 0;;
	-h|-help)	FullUsage; exit 0;;
	-*)		ErrorOption $1; exit 1;;
	*)		HandleFiles $1;;
   esac
   shift
done

######################################################### no file -> write help
 
n=${#afiles[@]}
if [ $n -le 0 ]; then
  Usage
  exit 1;
fi

######################################################### handle Xaxis

GetFirstAndLastDataLine
CheckForDate
if [ "$idate" = "YES" ]; then
  DetermineXrange
fi
if [ "$date" = "YES" ]; then
  HandleXrange		#splits and quotes
  HandleXaxis
  [ $debug == "YES" ] && echo "xformat: $xformat" >&2
fi

######################################################### write header

if [ $terminal = "png" ]; then
  orientation="small"
  orientation="large"
  output="out.png"
  type="size 1280,960"
  type="size 800,600"
else
  output="out.ps"
fi

title=$( DeleteUnderscore "$title" )

cat > gnu.tmp <<EOI

# $copy1
# $copy2
# $copy3
# $copy4

set terminal $terminal $orientation $type
set output "$output"

set style data lines
#set data style lines		#old call
#set data style linespoints
set datafile commentschars "#!%"
set title "$title"

EOI

if [ $date = "YES" ]; then
cat >> gnu.tmp <<EOI
set xdata time
set timefmt "$date_format"
set format x "$xformat"
set xtics rotate by $xrotate
EOI
fi

######################################################### write defaults

if [ -n "$xlabel" ]; then
  xlabel=$( DeleteUnderscore "$xlabel" )
  echo "set xlabel \"$xlabel\"" >> gnu.tmp
fi
if [ -n "$ylabel" ]; then
  ylabel=$( DeleteUnderscore "$ylabel" )
  echo "set ylabel \"$ylabel\"" >> gnu.tmp
fi

if [ -n "$xrange" ]; then
  echo "set xrange [$xrange]" >> gnu.tmp
fi
if [ -n "$yrange" ]; then
  echo "set yrange [$yrange]" >> gnu.tmp
fi
if [ -n "$offset" ]; then
  if [[ $offset == *[r]* ]]; then
    if [ $gpmajor -lt 4 ]; then
      echo "gnuplot version $gpversion does not allow relative offsets"
      exit 1
    fi
  fi
  offsets=$( echo $offset | sed -e 's/\([0-9\.][0-9\.]*\)r/ graph \1/g' )
  #echo "offsets: $offsets" 
  echo "set auto fix" >> gnu.tmp
  echo "set offsets $offsets" >> gnu.tmp
fi

if [ $orientation = "portrait" ]; then
  echo "set size 0.7,0.7" >> gnu.tmp
fi

if [ $grid = "YES" ]; then
  echo "set grid" >> gnu.tmp
fi

if [ $xlog = "YES" ]; then
  echo "set logscale x" >> gnu.tmp
fi

if [ $ylog = "YES" ]; then
  echo "set logscale y" >> gnu.tmp
fi

if [ -n "$xtics" ]; then
  if [ "$xtics" = "xdtics" ]; then
    echo "set xdtics" >> gnu.tmp
  elif [ "$xtics" = "xmtics" ]; then
    echo "set xmtics" >> gnu.tmp
  elif [ "$xtics" = "mesi" ]; then
    echo "set xtics ($mesi)" >> gnu.tmp
  elif [ "$xtics" = "months" ]; then
    echo "set xtics ($months)" >> gnu.tmp
  else
    echo "set xtics $xtics" >> gnu.tmp
  fi
fi

if [ -n "$y2label" -o -n "$y2range" ]; then		#second y-axis
  echo "set ytics nomirror" >> gnu.tmp
  echo "set y2tics" >> gnu.tmp
  if [ -n "$y2label" ]; then
    echo "set y2label \"$y2label\"" >> gnu.tmp
  fi
  if [ -n "$y2range" ]; then
    echo "set y2range [$y2range]" >> gnu.tmp
  fi
fi

if [ -n "$labels" -a -f "$labels" ]; then		#file with labels avail
  echo "" >> gnu.tmp
  cat $labels >> gnu.tmp
fi

echo "" >> gnu.tmp

######################################################### files to plot

#MakeFiles $@

files=${afiles[@]}

######################################################### adjust using command

aux=`echo $using | sed -e 's/ //g' | sed -e 's/using//'`
if [[ $aux =~ all ]]; then
  xcol=`echo $aux | sed -e 's/://g' | sed -e 's/all//'`
  [ -z "$xcol" ] && xcol=1
  allcol="YES"
else
  allcol="NO"
fi

#echo "allcol=$allcol  xcol=$xcol"
#exit 0

if [ $allcol = "YES" ]; then
  using="using $xcol:2"
  nfiles=${#afiles[@]}
  if [ $nfiles -gt 1 ]; then
    echo "-u all only with one file"
    exit 1
  fi
  rm -f column.*
  $extractcol -f column -x $xcol $files
  files=`ls column.*[0-9]`
  GiveNames
  #SetFilesAndAttributes $files
  deletefiles=$files
  InsertFiles
fi

######################################################### scale plot

if [ $xfact != "1" -o $yfact != "1" ]; then
  newfiles=""
  m=0
  while [ $m -lt ${#afiles[@]} ]
  do
    file=${afiles[$m]}
    newfile=${file}_
    $scalecol -s $xfact $file > tmp.tmp
    $scalecol -s $yfact -c 2 tmp.tmp > $newfile
    afiles[$m]=$newfile
    ((m++))
  done
  files=${afiles[@]}
fi

#ShowFiles
[ $verbose = "YES" ] && ShowFiles

######################################################### 

PlotFiles 

######################################################### insert logo

if [ $logo -ne 0 ]; then
  $gpsinsert -relative "$logo_where" $logo_file out.ps
  mv incl_out.ps out.ps
fi

######################################################### 

#echo "outfile: $outfile"
if [ -n "$outfile" ]; then
  if [ "$outfile" = "-" ]; then
    $ghost out.ps
  elif [ "$outfile" = "out.png" ]; then
    :
  else
    #rename out. $outfile. out.[1-9]*.ps out.ps		# old call
    rename "s/out\./$outfile./" out.[1-9]*.ps out.ps	# use perl expression
  fi
fi

#echo "files to be deleted:"
#echo "$deletefiles"
rm -f $deletefiles

######################################################### end

